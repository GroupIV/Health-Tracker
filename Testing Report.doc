						Testing Report

Introduction
The objective of testing the program is to ensure that the product being delivered meets the requirements and standards of the customer. Testing each aspect of the program makes certain that the program is delivering its function even if an error occurs thus proving a product that is both versatile and robust. The methods tested in this documentation for unit test cases are: addAccount, deleteAccount, getUser and addDailyRecord. Each unit test case will  The methods tested in this documentation for integration test planning are: User changed account, user deleted account, user created new account and user entered daily information.

TESTING
Unit Test Case (getUser)
public UserAccount getUser(String lastName, String firstName)
Given the last and first names of a person, this method should search the account list data structure in UserAccountList for any accounts that match the last and first name of that person.  If it does find an account with those names it returns it. Otherwise, it returns null. This functionality can be used both to retrieve an account and check for its existence.
The test plan for this method involves inputting the last and first names for accounts which do and do not exist looking for the correct results. It also involves mixing names that do exist with names which don’t to make sure that the last name AND the first name are required for the account to match, not the last name OR the first name. Finally, to exhaust options, the function is tested when the list of accounts is empty.
John Smith – Name of Existing Account
Jane Lester – Name of non-existing account
Test Case	#1	#2	#3	#4	#5	#6
lastName	Smith	Lester	Smith	Lester	Smith	Lester
firstName	John	Jane	Jane	John	John	Jane
List Empty?	No	No	No	No	Yes	Yes
Expected Out	UserAccount	null	null	null	null	null
Actual Out	UserAccount	null	null	null	null	null

 

Integration Test Plan (createNewAccount)
User Creates New Account
1. HealthTracker : main
2. FrameController : openChooseFrame
3. ChooseAccountMenu : openCreateFrame
4. CreateNewAccountMenu : submitButton.actionPerformed
5. AccountList : addUserAccount
6. UserAccount : constructor
When the program boots it needs to call the function which opens the “Choose Account Menu.” From there, they user needs to press a create new account button which calls the function that opens the “Create New Account Menu.” In the resulting JFrame, a user needs to enter the valid data into all the text fields and then press the submit button, which error handles the inputted data and tries to add a user account to the user account list by using the addUserAccount function and the UserAccount constructor.
When adding the new account, tests need to consider whether all or only some of the text fields are empty or only contain spaces, whether or not the user entered irrational height and age integer values (negative or impossibly large), whether or not the account trying to be added conflicts with a an already existing account (account with same first and last name exists), whether or not the account limit has been reached (20 accounts), and whether or not the user caused a numberFormatException by inputting non-integer values into integer text fields. Tests also need to confirm that if an account is able to be added, it actually is. 

Validation Test (getUser & createNewAccount)
“Are we building the right product?”	
After unit and integration testing it is apparent that this function is indeed correct in servicing the main functionality of this software product. This functionality is proved useful to the user in that it will allow them to both access their account information as well as create a new account which a vital to the operation of this software.

Unit Test Case (newUserAccount)
public void addUserAccount (userAccount newUser)
Given the last and first names of a person, this method should receive the passed parameters for last and first name as strings and invoke the user account constructor to add a new user to the user-list.
The test plan for this method involves inputting the last and first names for accounts and creating a new user account to add to the user list. It also involves mixing string names and invalid data types to make sure that the last name AND the first name are required as strings for the account to create.
John Smith – Valid first and last name account parameters
12 Lester – Invalid first and valid last name account parameters (note: 12 is of integer type)
12 true – Invalid first and invalid last name account parameters (note: true is of boolean type)
Test Case	#1	#2	#3
lastName	Smith	Lester	true
firstName	John	12	12
Expected Out	UserAccount	null	null
Actual Out	UserAccount	null	null

 
Integration Test Plan (changeAccount)
User selects to change account
1. HealthTracker : main
2. FrameController : openChooseFrame
3. ChooseAccountMenu : openCreateFrame
4. ChooseAccountMenu : chooseAccount.actionPerformed
5. AccountList : changeAccount
6. MainMenu : main

When the program boots it needs to call the function which opens the “Choose Account Menu.” From there, they user needs to press a change account button which calls the function that opens the “Change Account Menu.” In the resulting JFrame, a user needs to choose from the drop-down menu of account names and then press the submit button.

When changing the account, tests need to consider whether there are any accounts to choose from or not. If there are accounts available to choose from then the drop-down menu will present them whereas if there are no accounts to choose from then the drop-down menu will not display anything.

Validation Test (newUserAccount & changeAccount)
“Are we building the right product?”	
After unit and integration testing it is apparent that this function is indeed correct in servicing the main functionality of this software product. This functionality is proved useful to the user in that it will allow them to both add a user account and change user accounts which a vital to the operation of this software.

Unit Test Case (deleteUser)
Public boolean deleteUser(String lastName, String firstName)
Given the last and first names of a person, this method should call the getUser method to search for any accounts that match the last and first name. If it does find an account with those names, it calls the remove method in accountList to remove all data related to that user. If the list is empty or getUser method cannot find the matching last and first name, it should return false. This functionality can be used to delete an existing user account.
The test plan for this method involves inputting the last and first names for accounts which do and do not exist looking for correct results. It also involves mixing names that do exist with names which don’t to make sure that the last name AND the first name are required for the account to match, not the last name OR the first name. Finally, to exhaust options, the function is tested when the list of accounts is empty.
John Smith – Name of Existing Account
Jane Lester – Name of non-existing account
Test Case	#1	#2	#3	#4	#5
lastName	Smith	Lester	Smith	Lester	Smith
firstName	John	Jane	Jane	John	John
List Empty?	No	No	No	No	Yes
Expected Out	true	false	false	false	false
Actual Out	true	false	false	false	false

 


Integration Test Plan (deleteUser)
User Deletes Existing Account
1. HealthTracker : main
2. FrameController : openChooseFrame
3. ChooseAccountMenu : deleteAccount
4. UserAccountList : deleteUser
5. UserAccountList : getUser
6. AccountList : remove
When the program boots it needs to call the function which opens the “Choose Account Menu.” From there, they user needs to press a delete account button which calls the function that opens the “UserAccountList which contains method to delete an account.” Then the deleteUser account first calls getUser method to check if user account exist, if it do not exist, return false, if it does exist, deleteUser calls AccountList remove method to remove the account and return true.
When deleting the account, tests need to consider whether the account exist, if the first and last name matches, and check to make sure the account has been successfully deleted.

Validation Test (deleteUser)
“Are we building the right product?”	
After unit and integration testing it is apparent that this function is indeed correct in servicing the main functionality of this software product. This functionality is proved useful to the user in that it will allow them to delete a user account which is vital to the operation of this software.

Unit Test Case (addDailyRecord)
public boolean addDailyRecord (DailyRecord newDailyRecord)
Given the daily record of a person, this method should receive the passed parameter new daily record as a DailyRecord and invokes the addDailyRecord method to prompt the user to enter proper information into a window to store the daily record information for the day.
The test plan for this method involves inputting proper data types into fields for the associated account and stores the newly created daily record to the user for that day. It also involves mixing valid and invalid data types to make sure that the text fields are receiving/storing proper input. It will also check to make sure the user is not entering a daily record twice in one day as that is not the purpose of a daily record and will return null and warner the user that they cannot create two daily records in one day.
Valid parameters - User enters valid data types into the proper fields and has not created a daily record yet that same day
Invalid parameters - User enters invalid data types into the fields and has not created a daily record yet that same day 
Invalid parameters & Existing daily record - User enters valid data types into the proper fields and has already created a daily record that same day




Test Case	#1	#2	#3
Cardio-Hours	1	Yes	1
Strength-Hours	2	No	2
Work-Hours	8	No	8
Sleep-Hours	8	Yes	8
Systolic BP	120	True	120
Diastolic BP	80	False	80
Weight	330	Eighty	330
Calories Consumed	5000	Diet	5000
Blood Sugar	70	None	70
Pulse	120	Fast	120
Existing Daily Record	False	False	True
Expected Out	DailyRecord	null	null
Actual Out	DailyRecord	null	null

 
Integration Test Plan (addDailyRecord)
User enters daily information
1. HealthTracker : main
2. FrameController : openChooseFrame
3. ChooseAccountMenu : openCreateFrame
4. EnterInformationMenu : submitButton.actionPerformed
5. UserAccount : addDailyRecord
6. MainMenu : main

When the program boots and the user chooses Enter Daily Record menu option the program needs to call the function which opens the “Enter Information Menu.” From there, they user needs to enter the appropriate data in the fields and select the “Submit” button. If there are erros such as invalid data types or entering twice in one day then the user is prompt with a warning and stays on the current window to edit the information once more. Otherwise, the user is then taken to the main menu once again after the daily record has been successfully stored.

When entering a daily record, tests need to consider whether the input fields have correct parameters otherwise the program will display a warning pop-up to the user to enter valid parameters in the fields. The program also needs to test for if the user has already enter in a daily record that day and to not accept any more than one daily record in a day and warn the user (and return to main menu).

Validation Test(addDailyRecord)
“Are we building the right product?”	
After unit and integration testing it is apparent that this function is indeed correct in servicing the main functionality of this software product. This functionality is proved useful to the user in that it will allow them to add their daily record which is vital to the operation of this software.




SYSTEM TESTING

Recovery Testing: A non-functional testing done in order to maintain how efficiently the software can recover after it has gone through a crash or hardware failure. This is importantly relatable to our project in that the software’s ability to recover after a crash can save data from the users stored making it more convenient to the user.

Security Testing: A non-functional testing (a type of software testing) done in order to check if the software is secure or not. This is importantly relatable to our project in that the security of the user’s data is personal and it is important to keep the user’s information private and inaccessible to non-qualified users.

Stress Testing: Software testing done in order to determine the level of robustness of the system pushed beyond its intended limits. This is importantly relatable to our project in that it emphasis robustness, availability and error handling for the user making the overall product a more user friendly experience.

Performance Testing: General testing done in order to determine how a system performs in terms of responsiveness and stability over a given capacity. This is importantly relatable to our project in that it serves to investigate, measure, validate or verify other quality attributes of the software, such as reliability, resource usage and scalability.


CONCLUSION

	The purpose of the CSE360 class project is for students to get used to the many organizational structures and development practices used by companies in the software industry to bring a product to fruition. Towards these ends, our group decided to choose to develop a more restrained health tracking program: not skimping on important features, but also not putting too much energy into building something overelaborate while not paying much mind to the more pressing matter of learning the class material. Keeping reasonable expectations as to what we could create really helped simplify the whole process and reduced group stress. In the end, our hard work resulted in a product which resembled the original vision very closely. 

	For being a group composed almost entirely of people who did not know each other going into the project, Group 4’s dynamic was efficient, courteous, and robust. Each member did their own share of the work without needing extra motivation from others. Communication amongst the different members was effective and clear. Due to the good attitudes of everyone involved, there were no ugly conflicts between members that had to be dealt with. At the end of the second phase of the project, one of our group members, Jeremy, made a withdrawal from the class due to a change in major. He made this fact clear to all other members weeks ahead of time and offered to help us close up any loose ends his leaving would cause. This is but one example of how well our group worked together despite any circumstances.

	Though almost everything went very well for our group, there were of course several hiccups along the way. When it came to setting up everyone’s install of the Eclipse IDE to connect to our GitHub repository via EGit, several members ran into technical issues due to the apparently complexity of the process. It should be noted that no member in the group had any extensive experience with version control systems before this project, so learning how to use Git created a bit of a bump in the road. Another problem with the development of our health tracker program was the waste of resources on the prototype. As an interface for testing the methods and classes built in the prototype, we built a console based IO system. This entire system, however, would later be thrown away in favor of a GUI created with Java’s Swing library. We knew this, and perhaps could have prevented the waste of energy by finding a prototyping software or library which would allow for quick IO testing.

	To students who will take CSE360 in the future I would recommend scaling back ambitions; this decision turned out really well for us in the long run, allowing our group members to avoid becoming over encumbered by unnecessary work while missing the point of the project. Clear communication, regular team meetings, and defined team leaders are other features of success in this course.

	And now some statistics: there were zero defects found during phase one, since there no software existed at the time, there were two defects found during phase two in the prototype, both dealing with the loading and saving the list of user accounts, and there was only one defect found in the final build, which had to do with not covering all the bases in regards to Swing components.  

